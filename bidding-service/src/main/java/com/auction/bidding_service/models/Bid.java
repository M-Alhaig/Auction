package com.auction.bidding_service.models;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.proxy.HibernateProxy;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

/**
 * Entity representing a bid placed on an auction item.
 * <p>
 * Design Notes: - Uses @Version for optimistic locking as a database-level fallback to Redis
 * distributed locks - Timestamp is auto-generated on creation and cannot be modified - Bidder
 * cannot change their bid amount after submission (immutable bids) - itemId references Item
 * Service's items table (cross-service foreign key by convention only)
 * <p>
 * Concurrency Control: - Primary: Redis distributed lock on "lock:item:{itemId}" before bid
 * insertion - Fallback: @Version field prevents lost updates if Redis lock fails
 * <p>
 * Indexes: - idx_item_bid: Optimized for finding highest bid per item (ORDER BY bid_amount DESC) -
 * idx_bidder: Fast lookup of all bids by a specific user - idx_timestamp: Chronological bid history
 * queries
 */
@Entity
@Table(
    name = "bids",
    indexes = {
        @Index(name = "idx_item_bid", columnList = "item_id, bid_amount DESC"),
        @Index(name = "idx_bidder", columnList = "bidder_id"),
        @Index(name = "idx_timestamp", columnList = "timestamp DESC")
    }
)
@Getter
@Setter
@ToString
@RequiredArgsConstructor
public class Bid {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  /**
   * Reference to the auction item in Item Service. No @ManyToOne relationship - cross-service
   * boundary.
   */
  @Column(name = "item_id", nullable = false)
  private Long itemId;

  /**
   * UUID of the user who placed this bid. Extracted from JWT token or X-Auth-Id header.
   */
  @Column(name = "bidder_id", nullable = false)
  private UUID bidderId;

  /**
   * Bid amount in dollars. Must be greater than current highest bid for the item.
   */
  @Column(name = "bid_amount", nullable = false, precision = 10, scale = 2)
  private BigDecimal bidAmount;

  /**
   * Timestamp when the bid was placed. Auto-generated by Hibernate on persist.
   */
  @CreationTimestamp
  @Column(name = "timestamp", nullable = false, updatable = false)
  private LocalDateTime timestamp;

  /**
   * Version field for optimistic locking. Prevents lost updates if two transactions try to modify
   * the same bid simultaneously. Acts as fallback if Redis distributed lock fails or is
   * unavailable.
   */
  @Version
  @Column(name = "version")
  private Long version;

  /**
   * Hibernate-safe equals method. Compares by ID only, handles lazy-loading proxies correctly.
   * <p>
   * IMPORTANT: This implementation is required when using Lombok with Hibernate to avoid issues
   * with proxy objects and lazy loading.
   */
  @Override
  public final boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null) {
      return false;
    }
    Class<?> oEffectiveClass = o instanceof HibernateProxy
        ? ((HibernateProxy) o).getHibernateLazyInitializer().getPersistentClass()
        : o.getClass();
    Class<?> thisEffectiveClass = this instanceof HibernateProxy
        ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass()
        : this.getClass();
    if (thisEffectiveClass != oEffectiveClass) {
      return false;
    }
    Bid bid = (Bid) o;
    return getId() != null && Objects.equals(getId(), bid.getId());
  }

  /**
   * Hibernate-safe hashCode method. Uses class hashCode instead of ID to maintain consistency
   * across detached/managed states.
   */
  @Override
  public final int hashCode() {
    return this instanceof HibernateProxy
        ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass().hashCode()
        : getClass().hashCode();
  }
}
